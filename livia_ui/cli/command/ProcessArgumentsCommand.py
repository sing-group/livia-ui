import logging
from argparse import FileType, Namespace
from functools import reduce
from io import TextIOBase
from typing import Optional, List, Tuple

from livia.input.FileFrameInput import FileFrameInput
from livia.output.FileFrameOutput import FileFrameOutput
from livia.process.analyzer.AnalyzerFrameProcessor import AnalyzerFrameProcessor
from livia.process.analyzer.FrameAnalyzerManager import FrameAnalyzerManager
from livia.process.analyzer.FrameAnalyzerMetadata import FrameAnalyzerMetadata
from livia.process.analyzer.NoChangeFrameAnalyzer import NoChangeFrameAnalyzer
from livia.process.listener.ProcessChangeEvent import ProcessChangeEvent
from livia.process.listener.ProcessChangeListener import ProcessChangeListener
from livia_ui.cli import LIVIA_CLI_LOGGER
from livia_ui.cli.command.ArgumentsCommand import ArgumentsCommand
from livia_ui.cli.command.converters.ValueConverterFactory import ValueConverterFactory


class ProcessorListener(ProcessChangeListener):
    def started(self, event: ProcessChangeEvent):
        LIVIA_CLI_LOGGER.info(f"Video analysis started")

    def stopped(self, event: ProcessChangeEvent):
        event.processor.close()

    def finished(self, event: ProcessChangeEvent):
        LIVIA_CLI_LOGGER.info(f"Video analysis finished")


class ProcessArgumentsCommand(ArgumentsCommand):
    def __init__(self):
        super().__init__("process", "Video processing")

        self.__value_converter_factory: ValueConverterFactory = ValueConverterFactory()

    def _build_subparser(self, subparser):
        subparser.add_argument("-in", "--input", dest="input", type=FileType("r"), required=True,
                               help="Video input file")
        subparser.add_argument("-out", "--output", dest="output", type=FileType("w"), required=True,
                               help="Video output file")

        for analyzer in FrameAnalyzerManager.list_analyzers():
            group = subparser.add_argument_group("Analyzer " + analyzer.name)

            short_prefix = f"-an-{analyzer.id}-"
            long_prefix = f"--analyzer-{analyzer.id}-"

            group.add_argument(short_prefix + "order", long_prefix + "order", type=int, required=False,
                               help="Priority order of the analyzer")

            group.add_argument(short_prefix + "log-file", long_prefix + "log-file",
                               type=FileType("a", encoding="UTF-8"), required=False,
                               help="File to log analyzer messages to. \
                               If not specified, logging for this analyzer will be disabled")

            group.add_argument(short_prefix + "log-level", long_prefix + "log-level",
                               required=False, default="INFO",
                               help="Output log level name for the logger associated to the analyzer. \
                               If not specified, any records for the INFO level or above will be logged. \
                               Custom levels can be used with the help of the logging.addLevelName Python \
                               function")

            group.add_argument(short_prefix + "log-format", long_prefix + "log-format",
                               required=False, default="%(message)s",
                               help="Output format for the log records generated by the analyzer. \
                               If not specified, a basic, message only format will be used for log records. \
                               Analyzers may log records with custom fields, allowing them to be formatted \
                               independently from other fields according to the provided log format. \
                               For more information, check out Python's logging formatter documentation at \
                               https://docs.python.org/3/library/logging.html#logging.Formatter")

            for prop in analyzer.properties:
                group.add_argument(short_prefix + prop.id, long_prefix + prop.id, help=prop.prop.__doc__,
                                   required=False)

    def execute_command(self, args: Namespace):
        analyzer = self._build_analyzer(args)

        LIVIA_CLI_LOGGER.info(f"Processing {args.input.name} to {args.output.name}")
        input = FileFrameInput(args.input.name, 0)
        output = FileFrameOutput(args.output.name, input.get_fps(), *input.get_frame_size())

        processor = AnalyzerFrameProcessor(input, output, analyzer, daemon=False)
        processor.add_process_change_listener(ProcessorListener())

        processor.start()

    def _build_analyzer(self, args):
        analyzers: List[(int, FrameAnalyzerMetadata)] = []

        for analyzer_metadata in FrameAnalyzerManager.list_analyzers():
            analyzer_args, order, log_args = ProcessArgumentsCommand._extract_args_for_analyzer(args, analyzer_metadata)

            if analyzer_args is not None:
                analyzer = analyzer_metadata.analyzer_class()

                for prop_id, value in analyzer_args.__dict__.items():
                    prop = analyzer_metadata.get_property_by_id(prop_id)
                    if prop is not None:
                        try:
                            converter = self.__value_converter_factory.get_converter(prop.prop_type)
                            prop.set_value(analyzer, converter.convert(value))
                        except ValueError:
                            prop.set_value(analyzer, value)

                if log_args is not None:
                    log_file, log_level, log_format = log_args

                    logger = FrameAnalyzerManager.get_logger_for(analyzer)
                    logger.setLevel(log_level)
                    handler = logging.StreamHandler(log_file)
                    handler.setFormatter(logging.Formatter(log_format))
                    logger.addHandler(handler)

                analyzers.append((order, analyzer))

        if analyzers:
            analyzers.sort(key=lambda item: item[0], reverse=True)

            def add_child(a1, a2):
                a1.child = a2
                return a1

            analyzer = reduce(add_child, [analyzer_order[1] for analyzer_order in analyzers])
        else:
            analyzer = NoChangeFrameAnalyzer()

        return analyzer

    @staticmethod
    def _extract_args_for_analyzer(args: Namespace, analyzer: FrameAnalyzerMetadata) -> \
            Tuple[Optional[Namespace], Optional[int], Optional[Tuple[TextIOBase, str, str]]]:
        def arg(arg_id):
            return f"analyzer_{analyzer.id}_{arg_id}".replace("-", "_")

        order = getattr(args, arg("order"))
        log_file = getattr(args, arg("log_file"))
        log_level = getattr(args, arg("log_level"))
        log_format = getattr(args, arg("log_format"))

        if order is None:
            return None, None, None
        else:
            analyzer_args = Namespace()

            for prop in analyzer.properties:
                arg_value = getattr(args, arg(prop.id))
                if arg_value is not None:
                    setattr(analyzer_args, prop.id, arg_value)

            if log_file is not None:
                return analyzer_args, order, (log_file, log_level, log_format)
            else:
                return analyzer_args, order, None
